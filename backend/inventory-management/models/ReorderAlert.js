const mongoose = require('mongoose');

const reorderAlertSchema = new mongoose.Schema({
  part: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'Part',
    required: true
  },
  alertType: {
    type: String,
    required: true,
    enum: ['LOW_STOCK', 'OUT_OF_STOCK', 'OVERSTOCK', 'EXPIRED'],
    default: 'LOW_STOCK'
  },
  currentStock: {
    type: Number,
    required: true,
    min: [0, 'Current stock cannot be negative']
  },
  minStockLevel: {
    type: Number,
    required: true,
    min: [0, 'Minimum stock level cannot be negative']
  },
  suggestedOrderQuantity: {
    type: Number,
    min: [1, 'Suggested order quantity must be at least 1']
  },
  priority: {
    type: String,
    enum: ['LOW', 'MEDIUM', 'HIGH', 'CRITICAL'],
    default: 'MEDIUM'
  },
  status: {
    type: String,
    enum: ['ACTIVE', 'ACKNOWLEDGED', 'RESOLVED', 'DISMISSED'],
    default: 'ACTIVE'
  },
  acknowledgedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  acknowledgedAt: {
    type: Date
  },
  resolvedBy: {
    type: mongoose.Schema.Types.ObjectId,
    ref: 'User'
  },
  resolvedAt: {
    type: Date
  },
  notes: {
    type: String,
    trim: true,
    maxlength: [500, 'Notes cannot exceed 500 characters']
  },
  autoGenerated: {
    type: Boolean,
    default: true
  }
}, {
  timestamps: true
});

// Indexes for better query performance
reorderAlertSchema.index({ part: 1 });
reorderAlertSchema.index({ status: 1 });
reorderAlertSchema.index({ priority: 1 });
reorderAlertSchema.index({ alertType: 1 });
reorderAlertSchema.index({ createdAt: -1 });

// Pre-save middleware to calculate suggested order quantity
reorderAlertSchema.pre('save', function(next) {
  if (!this.suggestedOrderQuantity && this.part) {
    // Suggest ordering enough to reach max stock level
    this.suggestedOrderQuantity = Math.max(1, this.part.maxStockLevel - this.currentStock);
  }
  
  // Set priority based on stock level
  if (this.currentStock === 0) {
    this.priority = 'CRITICAL';
    this.alertType = 'OUT_OF_STOCK';
  } else if (this.currentStock <= this.minStockLevel * 0.5) {
    this.priority = 'HIGH';
  } else if (this.currentStock <= this.minStockLevel) {
    this.priority = 'MEDIUM';
  }
  
  next();
});

// Static method to create alert for part
reorderAlertSchema.statics.createAlertForPart = async function(partId) {
  const Part = mongoose.model('Part');
  const part = await Part.findById(partId);
  
  if (!part) {
    throw new Error('Part not found');
  }
  
  // Check if there's already an active alert for this part
  const existingAlert = await this.findOne({
    part: partId,
    status: 'ACTIVE'
  });
  
  if (existingAlert) {
    // Update existing alert
    existingAlert.currentStock = part.currentStock;
    existingAlert.minStockLevel = part.minStockLevel;
    return await existingAlert.save();
  }
  
  // Create new alert if stock is low
  if (part.currentStock <= part.minStockLevel) {
    const alert = new this({
      part: partId,
      currentStock: part.currentStock,
      minStockLevel: part.minStockLevel,
      suggestedOrderQuantity: part.maxStockLevel - part.currentStock
    });
    
    return await alert.save();
  }
  
  return null;
};

// Static method to resolve alerts for part
reorderAlertSchema.statics.resolveAlertsForPart = async function(partId, userId) {
  return await this.updateMany(
    { part: partId, status: 'ACTIVE' },
    {
      status: 'RESOLVED',
      resolvedBy: userId,
      resolvedAt: new Date()
    }
  );
};

module.exports = mongoose.model('ReorderAlert', reorderAlertSchema);